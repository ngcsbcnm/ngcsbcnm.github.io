[{"title":"test","date":"2023-07-27T07:31:56.000Z","url":"/2023/07/27/test/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"]],"categories":[["undefined",""]],"content":""},{"title":"Hello World","date":"2023-07-27T06:18:07.479Z","url":"/2023/07/27/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"},{"title":"笔试题","date":"2023-04-06T09:54:50.000Z","url":"/2023/04/06/%E7%AC%94%E8%AF%95%E9%A2%98/","tags":[["java","/tags/java/"]],"categories":[["undefined",""]],"content":"1.当请求过多，超出线程池负荷的时候，会触发拒绝策略。下列选项中，对于拒绝策略的描述错误的是（ C ）：A. CallerRunsPolicy，线程调用运行该任务的 execute 本身，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。B. AbortPolicy，处理程序遭到拒绝将直接抛出异常，丢弃任务。C. DiscardPolicy，不能执行的任务将被删除。这种策略将丢弃任务，同时也会抛出异常。D. DiscardOldestPolicy，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。 解析线程池拒绝策略： （1） AbortPolicy 。丢弃任务，并抛出RejectedExecutionException异常，线程池默认拒绝策略； （2） DiscardPolicy。丢弃任务，不抛出异常； （3） DiscardOldesPolicy.丢弃队列最前面的任务，然后重新提交被拒绝的任务； （4） CallerRunPolicy。由调用的线程处理该任务，谁调用谁的线程处理。 2.下列关于AOP术语的描述中，错误的是（ A ）：A. Joinpoint，是指目标对象上所定义的各个方法。B. Pointcut，是用来定义当前的横切逻辑准备织入到哪些连接点上。C. Advice，用来定义横切逻辑，即在连接点上准备织入什么样的逻辑。D. Aspect，是一个用来封装切点和通知的组件。 解析 连接点（Joinpoint）连接点描述的是程序执行的某个特定位置。如一个类的初始化前、初始化后，或者类的某个方法调用前、调用后、方法抛出异常后等等。一个类或一段程序代码拥有一些具有边界性质的特定点，这些特定点就称为连接点。连接点用来定义在目标程序的哪里通过AOP加入新的逻辑。 Spring仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。连接点由两个信息确定：第一是用方法表示的程序执行点；第二是用相对点表示的方位。执行点：即程序执行流程中的某个点。如执行某个语句或者语句块、执行某个方法、装载某个类、抛出某个异常…… 切入点（Pointcut）切入点是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。每个类都拥有多个连接点：例如 UserService类中的所有方法实际上都是连接点，即连接点是程序类中客观存在的事物。类比：连接点相当于数据库中的记录，切点相当于查询条件。切点和连接点不是一对一的关系，一个切点匹配多个连接点，切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。 通知（Advice）切面在某个具体的连接点采取的行为或行动，称为通知。切面的核心逻辑代码都写在通知中，有人也称之为增强或者横切关注点。通知是切面功能的具体实现，通常是业务代码以外的需求，如日志、验证等，这些被模块化的特殊对象。常用的通知接口有 前置通知：org.springframework.aop.MethodBeforeAdvice后置通知：org.springframework.aop.AfterReturningAdvice异常通知：org.springframework.aop.ThrowsAdvice该接口没有要实现的方法，需要自定义一个afterThrowing()方法。环绕通知：org.aopalliance.intercept.MethodInterceptor 通知器（Advisor）通知器由一个切入点（pointcut）和一个通知（Advice）组成。通知就是增强的那部分功能代码，如记录日志代码、控制权限代码。 切面（Aspect）与通知器（advisor）类似都是通知+切入点。区别在于，切面中的类无需实现通知接口，但需要在配置文件中指定类中的方法名；而通知器仅需指定类名即可，因为通知器中的类都实现了通知接口，很明确的知道通知方法是哪个。 目标(Target)被通知的对象（方法） 代理(Proxy)向目标对象应用通知之后创建的对象 3.JVM中有很多垃圾回收策略，其中会用到很多垃圾收集器，如果我们将垃圾收集器的作用范围划分为新生代和老年代的话，那么以下哪个选项中的所有收集器的作用域是属于老年代（B）A. Serial收集器、ParNew收集器、Paraller Scavenge收集器B. Serial Old收集器、Paraller Old收集器、CMS收集器C. Serial Old收集器、Paraller Old收集器、Paraller Scavenge收集器D. CMS收集器、ParNew收集器、Paraller Scavenge收集器 解析这个主要考察各个收集器的作用域，A选项中所有收集器的作用域是新生代，B选项中所有收集器的作用域是老年代，C、D选项各有错误。年轻代：serial GC、parNew GC、paraller Scavenge GC老年代：serial old GC 、paraller old GC、CMS 4.下面几项关于Java程序初始化的几个原则：①静态对象（变量）优先于非静态对象（变量）初始化；②父类优先于子类进行初始化；③按照成员变量的定义顺序进行初始化；其中正确的有：（D）A. ①②B. ①③C. ②③D. ①②③ 解析java程序中的初始化顺序可以归纳为： 静态成员变量和静态代码块的初始化顺序。 实例成员变量和实例代码块的初始化顺序。 构造方法的初始化顺序。 需要注意的是，在Java程序中存在继承关系时，初始化顺序还需要遵循特定的规则，即先初始化父类的静态成员变量和静态代码块，然后是子类的静态成员变量和静态代码块，接着是父类的实例成员变量和实例代码块，最后是子类的实例成员变量和实例代码块。 5.以下哪个不是分布式锁的实现方式（B）A. 使用数据库乐观锁实现B. 使用数据库悲观锁实现C. 使用redis的setnx()、expire()方法，用于分布式锁D. 基于Zookeeper实现分布式锁 解析使用数据库悲观锁实现不是分布式锁的实现方式，悲观锁通常是在单个数据库实例上使用的，而分布式锁是为了协调不同进程或不同节点之间的资源访问而设计的。分布式锁的实现方式可以使用数据库乐观锁、Redis的setnx()、Zookeeper等技术实现。 6.对于数列4、5、6、7、9、12、18、23，如果采用折半查找元素9，请问需要查找几次？（B）A. 2B. 3C. 4D. 5 解析4、5、6、7、9、12、18、23 Array[(0 + n - 1) &#x2F; 2] 小于 9, (0 + n - 1) &#x2F; 2 &#x3D; 3 Array[(3 + 1 + n - 1) &#x2F; 2] 大于 9, (3 + 1 + n - 1) &#x2F; 2 &#x3D; 5 Array[(3 + 1 + 5 - 1) &#x2F; 2] 等于 9所以, 一共3次 7.现有一字符串”hello world”，使用哈夫曼编码最少使用多少bit内存：（B）A. 4B. 32C. 64D. 88 8.已知现有一个大小为4初始状态为空的栈，现在有一组数据经过这个栈后，最终的数据顺序是:2 5 4 1 3,问原始的进栈数据不可能是以下的哪组:(D)A. 1 4 5 2 3B. 5 2 3 1 4C. 3 4 5 2 1D. 4 1 3 5 2 解析9.假设有一张表test,表中存放着全国的城市信息以及其所在的省份,现在要以每个省份包含名称以’州’为结尾的城市数量降序排序,包含相同数量的省份以省份名称降序拍戏,最终输出第二多以及第三多的省份以及数量,那么下面正确的sql语句是（B） A. select province, count() c from test where city like ‘%州’ group by province order by c desc, province desc limit 2,1B. select province, count() c from test where city like ‘%州’ group by province order by c desc, province desc limit 1,2C. select province, count() c from test where city like ‘州%’ group by province order by c desc, province desc limit 2,1D. select province, count() c from test where city like ‘州%’ group by province order by c desc, province desc limit 1,2"},{"title":"中值定理","date":"2023-03-24T14:39:47.000Z","url":"/2023/03/24/%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"]],"categories":[["undefined",""]],"content":"罗尔定理具体地，如果函数 满足以下条件： 在闭区间 [a,b] 内连续； 在开区间 (a,b) 内可导； 。 则存在至少一个点，使得。 证明： 在闭区间连续，则在是有界的，即存在最小值 m,和最大值 M， 使得，若 m&#x3D;M,则为常数函数，可得,满足证明要求，若 ,又因为，则(a,b)区间至少存在一点,使得或,因此区间存在一点为极大值点或极小值点，则存在至少一个点 ，使得 。 拉格朗日中值定理设函数在闭区间 上连续，在开区间 内可导，则存在点 使得： 证明定义辅助函数令 ,即曲线方程减去 ab 直线方程，其中 是函数在区间 [a,b] 上的平均斜率（即直线 AB 的斜率），g(x) 代表的是函数 f(x) 相对于直线 AB 的偏差。 求辅助函数在区间端点的取值 此时要求出 和 的值。 求辅助函数的导数根据题设，可知在内可导 ，所以也在 内可导。现在对 在内求导得： 根据罗尔定理，如果一个函数在闭区间 [a,b] 内连续，在开区间 (a,b) 内可导，并且在 a 和 b 处的函数值相等，那么在 (a,b) 内至少存在一个点 ，使得 。因为 g(a) &#x3D; g(b)，所以 g(x) 满足罗尔定理的所有条件，可以找到一个点 ，使得。 得出拉格朗日中值定理的结论 因为 ，所以。将等式两侧乘以， 得： 因此，存在一个点，使得，即拉格朗日中值定理成立。 柯西中值定理设满足在区间连续，在内可导，，则存在使得 证明构造函数 由于因此存在一点使得 所以 因此，即柯西中值定理成立。 泰勒公式1. 带拉格朗日余项的 n 阶泰勒公式设在处具有阶导数，则有带拉格朗日余项的 n 阶泰勒公式： 其中，为拉格朗日余项，具体形式为： 其中，介于和之间。 2.带配亚诺余项的 n 阶泰勒公式设在处具有阶导数，则有带配亚诺余项的阶泰勒公式： 其中，为配亚诺余项，具体形式为： "},{"title":"导数与微分","date":"2023-03-19T11:58:04.000Z","url":"/2023/03/19/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"]],"categories":[["undefined",""]],"content":"导数定义假设有一个平面直角坐标系，其中点是一条函数的图像上的一点。 如果从沿着正方向移动一个很小的量，对应的值分别为和。那么，通过点和该点的邻近点可以画出一条直线， 记为。当趋近于时，越来越接近于函数上的一条直线，这条直线称为函数在点处的切线。函数在这一点的导数为这条切线的斜率，表示为： 也可以写成 如果这个极限存在，那么函数在处可导，否则在处不可导。如果函数在其定义域内每一点都可导，那么这个函数就是可导的函数。 微分定义微分是导数概念的扩展，它描述的是函数在某点处的局部变化情况，也是微积分中的基本概念之一。 对于函数，在处微分表示在处的变化量，即： 其中是函数在处的导数，是自变量的增量。 将微分与自变量的增量的关系写成极限形式： 可以看出，微分就是函数在处的变化量随着自变量增量的极限。微分也可以表示为 ，其中表示自变量的增量。 微分和导数之间的关系非常密切，可以用微分来计算导数，也可以用导数来计算微分。 对于函数，其微分和第一种导数定义的关系可以表示为： 这意味着微分在某种程度上等价于函数在处的增量。"},{"title":"函数的连续与间断","date":"2023-03-19T05:50:19.000Z","url":"/2023/03/19/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E4%B8%8E%E9%97%B4%E6%96%AD/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"]],"categories":[["undefined",""]],"content":"连续点的定义设函数在的某个邻域内有定义，则是的连续点， 当且仅当 ，即在点左右极限都存在且相等于。 间断点的定义与分类1.可去间断点在这类间断点处，函数在该点左右极限存在且相等，但该点的函数值与极限值不相等。 例如，函数在处有一个可去间断点。 2.跳跃间断点在这类间断点处，函数在该点左右极限存在，但两侧极限不相等。 例如，函数（的底部函数）在所有整数点上都有跳跃间断点。 3.无穷间断点在这类间断点处，函数在该点左或右至少一个极限不存在或为无穷大。 例如，函数在处有一个无穷间断点。 4.混合间断点在这类间断点处，函数同时满足上述多种间断点性质。 例如，函数在所有整数点上都有混合间断点。"},{"title":"函数极限","date":"2023-03-19T05:46:05.000Z","url":"/2023/03/19/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"]],"categories":[["undefined",""]],"content":"函数极限定义设是一个实函数，是实数，若对于任意给定的正实数， 存在正实数，使得当满足时，都成立，其中为常数，则称是函数当趋近于时的极限，记为。 注：如果一个函数在趋近于的过程中极限为， 那么可以使用如下形式来表示该函数： 其中，为函数在趋近于时的极限，为一个无穷小量， 其极限为0。换句话说，当无限接近于时，的值趋近于。这种表示方式称为是使用极限运算符表示函数，它表示了当趋近于的时候，与其极限的差异可以被看作一个无穷小量。这个无穷小量通常是一个关于的表达式，但其值的大小可以被看作趋近于。 使用这种表示方法有助于分析函数在附近的行为，以及它的变化趋势。 函数极限性质1.唯一性如果存在，则该极限唯一。 2.保号性若，且（或）， 则存在a的某个邻域，使得在该邻域内，或。 3.局部有界性若，则存在一个正数和正实数， 使得当时，。换句话说，函数在点的某个去心邻域内是有界的。 海涅定理设是定义在区间上的函数，。 则的充分必要条件是： 对于的任何一个收敛于的数列，都有。 也就是说，如果函数在处极限存在， 那么对于的任何一组趋近于的数列，这组数列在下的极限都存在， 且这两个极限相等。反之，如果函数在处极限不存在，则存在的一个数列， 使得该数列收敛于，但不存在。 无穷小定义在数学中，无穷小是指一个数列或者函数，如果它在某一点处的极限等于零，那么就称该数列或函数在该点处是无穷小。具体地说， 对于函数，如果，则称函数在点处为无穷小。 无穷小的定义有多种等价表述方式，其中一种是：如果对于任意正实数，都存在正实数，使得当满足时， 有，则称函数在点处为无穷小。 无穷小可以是正无穷小、负无穷小和趋于零的无穷小。一个序列或者函数在某点处为无穷小，意味着在这个点附近，它的取值非常的小（接近于零），可以用来描述相对变化率微小的情况或者某些极限中的近似情况。 无穷小运算规则1.有限常数与无穷小的乘积也是无穷小。具体而言，如果是一个常数，是无穷小，那么也是无穷小。 这条规则可以表示为，其中的是”量级为f(x)的无穷小”的意思。 2.有限常数与无穷小的和差仍是无穷小。具体而言，如果和是两个常数，和分别是两个无穷小， 那么也是一个无穷小。同样地，也是一个无穷小。 这两条规则可以表示为： ， 。 其中的是和的上确界。 3.无穷小的乘积是无穷小。具体而言，如果和是两个无穷小，那么也是一个无穷小。 这个规则的表达式为。 4.无穷小的幂次是无穷小。具体而言，如果是一个无穷小，是一个正整数（）， 那么（的次方）也是一个无穷小。 这个规则的表达式为。 需要注意的是，这些运算规则中的等号并不是严格的等式，而是“等价”的关系。例如， 等于，意思是两个量级在一定意义上是等价的，但精确的数值大小还是要根据实际情况来判断。 常用的等价无穷小当趋近于零时， ，， ，，， ，。 当趋近于零时，，。这些等价无穷小可以方便地处理指数函数的极限和近似计算。 当x趋近于零时，。这个等价无穷小可以应用于某些复杂的极限计算中。 当x趋近于零时，，，，。这些等价无穷小可以方便地处理双曲函数的极限和近似计算。"},{"title":"数列极限","date":"2023-03-17T11:55:49.000Z","url":"/2023/03/17/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/","tags":[["高数","/tags/%E9%AB%98%E6%95%B0/"]],"categories":[["undefined",""]],"content":"1. 数列极限定义设为一数列，若存在常数，对正整数， 使得当n&gt;N时，恒成立，则称数是数列的极限， 或者称数列收敛与，记为 定理： 若数列收敛，则其任何子列也收敛， 且 2.收敛数列的性质唯一性：给出数列若则是唯一的。有界性：若数列极限存在，则数列有界。保号性：设数列存在极限a，且a&gt;0(或a&lt;0),则存在正整数N，当n&gt;N时，有或 3.夹逼准则如果数列满足 且 则 4.单调有界准则单调有界数列必有极限，即若数列单调增加减少且有上界下界 则存在"},{"title":"tmux和vim","date":"2023-03-04T13:53:05.000Z","url":"/2023/03/04/tmux%E5%92%8Cvim/","tags":[["Linux","/tags/Linux/"]],"categories":[["undefined",""]],"content":"tmux tmux操作 vim教程"},{"title":"树的遍历","date":"2023-02-20T11:54:38.000Z","url":"/2023/02/20/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/","tags":[["递归","/tags/%E9%80%92%E5%BD%92/"],["BFS","/tags/BFS/"],["树的遍历","/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"]],"categories":[["undefined",""]],"content":"题目一个二叉树，树中每个节点的权值互不相同。现在给出它的后序遍历和中序遍历，请你输出它的层序遍历。 输入格式第一行包含整数 N，表示二叉树的节点数。 第二行包含 N个整数，表示二叉树的后序遍历。 第三行包含 N个整数，表示二叉树的中序遍历。 输出格式输出一行 N个整数，表示二叉树的层序遍历。 数据范围1≤N≤30官方并未给出各节点权值的取值范围，为方便起见，在本网站范围取为 1∼N。 输入样例 输出样例 "},{"title":"Linux常用文件管理命令","date":"2023-02-20T10:36:27.000Z","url":"/2023/02/20/Linux%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/","tags":[["Linux","/tags/Linux/"]],"categories":[["undefined",""]],"content":"取消命令并换行 清空本行命令 补全命令和文件名 显示目录下的文件 显示当前路径 进入目录 复制文件 创建目录 删除文件 移动文件 创建文件 展示文件 复制文本 粘贴文本 ​ "}]